paste0(prediction_set_working$region[little_lga_rows],"_OTHER_OTHER")
big_wards = table(prediction_set_working$ward_lga) %>%
as.data.frame() %>%
filter(Freq >= 50) %>%
.$Var1
big_ward_rows = prediction_set_working$ward_lga %in% big_wards
prediction_set_working$admin_district[big_ward_rows] =
paste0(prediction_set_working$region[big_ward_rows],"_",
prediction_set_working$lga[big_ward_rows],"_",
prediction_set_working$ward[big_ward_rows])
####Weight of Information transformation for admin_district####
admin_district_woe =
as.data.frame.matrix(
table(prediction_set_working$admin_district,prediction_set_working$status_group)
)
admin_district_woe = admin_district_woe %>%
setNames(c("functional","functional_repair","non_functional"))
functional_count = sum(admin_district_woe$functional)
nonfunctional_count = sum(admin_district_woe$non_functional)
repairfunctional_count = sum(admin_district_woe$functional_repair)
admin_district_woe$woe_region_functional = log(
( (admin_district_woe$functional + 0.0001) / functional_count ) /
(
(admin_district_woe$functional_repair + admin_district_woe$non_functional + 0.0001 ) /
(nonfunctional_count + repairfunctional_count)
)
) %>%
round(5)
admin_district_woe$woe_region_repair = log (
( (admin_district_woe$functional_repair + 0.0001) /  repairfunctional_count) /
(
(admin_district_woe$functional + admin_district_woe$non_functional + 0.0001 ) /
(nonfunctional_count + functional_count)
)
)    %>%
round(5)
admin_district_woe$woe_region_nonfunctional = log (
( (admin_district_woe$non_functional + 0.0001) / nonfunctional_count ) /
(
(admin_district_woe$functional + admin_district_woe$functional_repair + 0.0001 ) /
(repairfunctional_count + functional_count)
)
)    %>%
round(5)
admin_district_woe$admin_district = row.names(admin_district_woe)
rownames(admin_district_woe) = 1:nrow(admin_district_woe)
saveRDS(admin_district_woe, "admin_district_woe.RDS")
prediction_set_working = merge(prediction_set_working,
admin_district_status[,c("admin_district","woe_region_functional","woe_region_repair","woe_region_nonfunctional")],
by = "admin_district",
all.x = TRUE)
prediction_set_working = merge(prediction_set_working,
admin_district_woe[,c("admin_district","woe_region_functional","woe_region_repair","woe_region_nonfunctional")],
by = "admin_district",
all.x = TRUE)
prediction_set_working = prediction_set_working %>%
rename(altitude_metres = gps_height)
prediction_set_complete = prediction_set_working[
!prediction_set_working$longitude == 0 &
!prediction_set_working$altitude_metres == 0,]
geo_cluster_vars = c("longitude",
"latitude",
"altitude_metres")
geoClstr_Task = makeClusterTask(data = prediction_set_complete[,geo_cluster_vars])
install.packages("mlr")
library(mlr)
prediction_set_working = prediction_set_working %>%
rename(altitude_metres = gps_height)
prediction_set_complete = prediction_set_working[
!prediction_set_working$longitude == 0 &
!prediction_set_working$altitude_metres == 0,]
geo_cluster_vars = c("longitude",
"latitude",
"altitude_metres")
geoClstr_Task = makeClusterTask(data = prediction_set_complete[,geo_cluster_vars])
library(mlr)
install.packages("checkmate")
library(checkmate)
library(checkmate)
library(checkmate)
install.packages("checkmate")
da_packages = c(
'tidyverse',
'lubridate',
'FNN',
'stringdist',
'OneR',
'checkmate'
'mlr',
'clue',
'clusterSim')
da_packages = c(
'tidyverse',
'lubridate',
'FNN',
'stringdist',
'OneR',
'checkmate',
'mlr',
'clue',
'clusterSim')
for(p in da_packages) {
if(!p %in% rownames(installed.packages())) {
install.packages(p)
}
library(p, character.only = TRUE)
}
predictors =
read.csv("data/4910797b-ee55-40a7-8668-10efd5c1b960.csv") %>% as_tibble()
####Read in the data and custom functions####
predictors =
read.csv("data/4910797b-ee55-40a7-8668-10efd5c1b960.csv") %>% as_tibble()
response =
read.csv("data/0bf8bc6e-30d0-4c50-956a-603fc693d966.csv") %>% as_tibble()
source('data_preparation/functions.R')
#####Join the predictors to response####
prediction_set_working =
merge(response,
predictors,
by = "id") %>%
as.tibble()
#####Add weekday transformation####
weekday = c('Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday',  'Saturday', 'Sunday')
prediction_set_working$date_recorded_POSIX = as.POSIXct(prediction_set_working$date_recorded)
prediction_set_working$weekday_recorded = weekdays(prediction_set_working$date_recorded_POSIX) %>%
factor(levels = weekday)
####Combine ward with LGA####
prediction_set_working$ward_lga = paste0(prediction_set_working$ward,"_",prediction_set_working$lga)
####Clean up and combine subvillage####
prediction_set_working$subvillage = tolower(prediction_set_working$subvillage)
prediction_set_working$subvillage = gsub("[^[:alpha:] ]","",prediction_set_working$subvillage)
prediction_set_working$subvillage = gsub('\\b\\w{1}\\b','',prediction_set_working$subvillage)
prediction_set_working$subvillage = gsub("  "," ",prediction_set_working$subvillage)
prediction_set_working$subvillage = trimws(prediction_set_working$subvillage)
prediction_set_working$subvillage[prediction_set_working$subvillage == ''] = NA
prediction_set_working$subvillage_ward_lga = paste0(prediction_set_working$subvillage, "_", prediction_set_working$ward_lga)
prediction_set_working$subvillage_ward_lga[is.na(prediction_set_working$subvillage)] = NA
####Create admin region####
prediction_set_working$admin_district = paste0(prediction_set_working$region,"_",prediction_set_working$lga,"_OTHER")
little_lgas = table(prediction_set_working$lga) %>%
as.data.frame() %>%
filter(Freq < 50) %>%
.$Var1
little_lga_rows = prediction_set_working$lga %in% little_lgas
prediction_set_working$admin_district[little_lga_rows] =
paste0(prediction_set_working$region[little_lga_rows],"_OTHER_OTHER")
big_wards = table(prediction_set_working$ward_lga) %>%
as.data.frame() %>%
filter(Freq >= 50) %>%
.$Var1
big_ward_rows = prediction_set_working$ward_lga %in% big_wards
prediction_set_working$admin_district[big_ward_rows] =
paste0(prediction_set_working$region[big_ward_rows],"_",
prediction_set_working$lga[big_ward_rows],"_",
prediction_set_working$ward[big_ward_rows])
####Weight of Information transformation for admin_district####
admin_district_woe =
as.data.frame.matrix(
table(prediction_set_working$admin_district,prediction_set_working$status_group)
)
admin_district_woe = admin_district_woe %>%
setNames(c("functional","functional_repair","non_functional"))
functional_count = sum(admin_district_woe$functional)
nonfunctional_count = sum(admin_district_woe$non_functional)
repairfunctional_count = sum(admin_district_woe$functional_repair)
admin_district_woe$woe_region_functional = log(
( (admin_district_woe$functional + 0.0001) / functional_count ) /
(
(admin_district_woe$functional_repair + admin_district_woe$non_functional + 0.0001 ) /
(nonfunctional_count + repairfunctional_count)
)
) %>%
round(5)
admin_district_woe$woe_region_repair = log (
( (admin_district_woe$functional_repair + 0.0001) /  repairfunctional_count) /
(
(admin_district_woe$functional + admin_district_woe$non_functional + 0.0001 ) /
(nonfunctional_count + functional_count)
)
)    %>%
round(5)
admin_district_woe$woe_region_nonfunctional = log (
( (admin_district_woe$non_functional + 0.0001) / nonfunctional_count ) /
(
(admin_district_woe$functional + admin_district_woe$functional_repair + 0.0001 ) /
(repairfunctional_count + functional_count)
)
)    %>%
round(5)
admin_district_woe$admin_district = row.names(admin_district_woe)
rownames(admin_district_woe) = 1:nrow(admin_district_woe)
saveRDS(admin_district_woe, "admin_district_woe.RDS")
prediction_set_working = merge(prediction_set_working,
admin_district_woe[,c("admin_district","woe_region_functional","woe_region_repair","woe_region_nonfunctional")],
by = "admin_district",
all.x = TRUE)
prediction_set_working = prediction_set_working %>%
rename(altitude_metres = gps_height)
prediction_set_complete = prediction_set_working[
!prediction_set_working$longitude == 0 &
!prediction_set_working$altitude_metres == 0,]
geo_cluster_vars = c("longitude",
"latitude",
"altitude_metres")
geoClstr_Task = makeClusterTask(data = prediction_set_complete[,geo_cluster_vars])
geoClstr_param <- makeParamSet(
makeDiscreteParam('centers', values = c(8:20))
)
geoClstr_resample = makeResampleDesc('CV', iters = 3)
geoClstr_ctrl = makeTuneControlGrid()
geoClstr_tune = tuneParams('cluster.kmeans',
task = geoClstr_Task,
resampling = geoClstr_resample,
par.set = geoClstr_param,
control = geoClstr_ctrl)
library(clusterSim)
install.packages("geneFilter")
install.packages("genefilter")
library(genefilter)
remove.packages('checkmate')
remove.packages('mlr')
remove.packages('clue')
remove.packages('clusterSim')
library(mlr)
install.packages("mlr")
install.packages("mlr")
geoClstr_resample = makeResampleDesc('CV', iters = 3)
library(mlr)
geoClstr_tune = tuneParams('cluster.kmeans',
task = geoClstr_Task,
resampling = geoClstr_resample,
par.set = geoClstr_param,
control = geoClstr_ctrl)
install.packages("clue")
geoClstr_tune = tuneParams('cluster.kmeans',
task = geoClstr_Task,
resampling = geoClstr_resample,
par.set = geoClstr_param,
control = geoClstr_ctrl)
logFunDefault = function(learner, task, resampling, measures, par.set, control, opt.path, dob,
x.string, y, remove.nas, stage, prev.stage, prefixes) {
if (stage == 1L) {
start.time = Sys.time()
messagef("[%s] %i: %s", prefixes[stage], dob, x.string)
return(list(start.time = start.time))
} else if (stage == 2L) {
end.time = Sys.time()
diff.time = difftime(time1 = end.time, time2 = prev.stage$start.time, units = "mins")
messagef("[%s] %i: %s; time: %.1f min",
prefixes[stage], dob, perfsToString(y), diff.time[[1]])
return(NULL)
}
}
geoClstr_tune = tuneParams('cluster.kmeans',
task = geoClstr_Task,
resampling = geoClstr_resample,
par.set = geoClstr_param,
control = geoClstr_ctrl)
for(p in da_packages) {
remove.packages(p)
}
cond_inst_package = function(p) {
if(!p %in% rownames(installed.packages())) {
install.packages(p)
}
}
cond_inst_package('mlr')
p
library(mlr)
install.packages('mlr')
install.packages("mlr")
library(mlr)
geoClstr_tune = tuneParams('cluster.kmeans',
task = geoClstr_Task,
resampling = geoClstr_resample,
par.set = geoClstr_param,
control = geoClstr_ctrl)
install.packages('clue')
library(clue)
geoClstr_tune = tuneParams('cluster.kmeans',
task = geoClstr_Task,
resampling = geoClstr_resample,
par.set = geoClstr_param,
control = geoClstr_ctrl)
install.packages('mlr')
library(mlr)
install.packages('clue')
library(clue)
predictors =
read.csv("data/4910797b-ee55-40a7-8668-10efd5c1b960.csv") %>% as_tibble()
geoClstr_tune = tuneParams('cluster.kmeans',
task = geoClstr_Task,
resampling = geoClstr_resample,
par.set = geoClstr_param,
control = geoClstr_ctrl)
?messagef
install.packages('BBmisc')
install.packages("BBmisc")
library(BBmisc)
library(BBmisc)
remove.packages('BBmisc')
library(BBmisc)
remove.packages('BBmisc')
install.packages('BBmisc')
library(BBmisc)
library(mlr)
library(clue)
geoClstr_tune = tuneParams('cluster.kmeans',
task = geoClstr_Task,
resampling = geoClstr_resample,
par.set = geoClstr_param,
control = geoClstr_ctrl)
install.packages('clusterSim')
library(clusterSim)
install.packages('genefilter')
library(genefilter)
geoClstr_tune = tuneParams('cluster.kmeans',
task = geoClstr_Task,
resampling = geoClstr_resample,
par.set = geoClstr_param,
control = geoClstr_ctrl)
geoClstr_param <- makeParamSet(
makeDiscreteParam('k', values = c(8:20))
)
geoClstr_tune = tuneParams('cluster.SimpleKMeans',
task = geoClstr_Task,
resampling = geoClstr_resample,
par.set = geoClstr_param,
control = geoClstr_ctrl)
install.packages('RWeka')
library(RWeka)
library(mlr)
library(clue)
library(BBmisc)
library(genefilter)
install.packages('genefilter')
library(genefilter)
install.packages('RWeka')
library(RWeka)
library(rJava)
setRepositories()
setRepositories(ind = c(1:6, 8))
setRepositories()
setRepositories()
install.packages('genefilter')
geoClstr_param <- makeParamSet(
makeDiscreteParam('centers', values = c(8:20))
)
geoClstr_tune = tuneParams('cluster.kmeans',
task = geoClstr_Task,
resampling = geoClstr_resample,
par.set = geoClstr_param,
control = geoClstr_ctrl)
remove.packages(c('mlr','clue','BBmisc','genefilter','RWeka'))
install.packages('mlr')
install.packages("mlr")
detach('mlr')
detach(mlr)
install.packages('mlr')
library(mlr)
install.packages('clue')
library(clue)
install.packages('BBmisc')
install.packages('genefilter')
library(genefilter)
install.packages('RWeka')
library(RWeka)
geoClstr_tune = tuneParams('cluster.kmeans',
task = geoClstr_Task,
resampling = geoClstr_resample,
par.set = geoClstr_param,
control = geoClstr_ctrl)
geoClstr_param <- makeParamSet(
makeDiscreteParam('centers', values = c(8:20))
)
geoClstr_Task = makeClusterTask(data = prediction_set_complete[,geo_cluster_vars])
geoClstr_param <- makeParamSet(
makeDiscreteParam('centers', values = c(8:20))
)
geoClstr_resample = makeResampleDesc('CV', iters = 3)
geoClstr_ctrl = makeTuneControlGrid()
geoClstr_tune = tuneParams('cluster.kmeans',
task = geoClstr_Task,
resampling = geoClstr_resample,
par.set = geoClstr_param,
control = geoClstr_ctrl)
install.packages('clusterSim')
library(clusterSim)
geoClstr_tune = tuneParams('cluster.kmeans',
task = geoClstr_Task,
resampling = geoClstr_resample,
par.set = geoClstr_param,
control = geoClstr_ctrl)
requirePackages("clusterSim", default.method = "load")
require("clusterSim", default.method = "load")
require("clusterSim")
setRepositories()
setRepositories(ind = c(1:6, 8))
library(clusterSim)
install.packages('clusterSim')
library(clusterSim)
install.packages('genefilter')
library(genefilter)
library(clusterSim)
geoClstr_tune = tuneParams('cluster.kmeans',
task = geoClstr_Task,
resampling = geoClstr_resample,
par.set = geoClstr_param,
control = geoClstr_ctrl)
geoClstr_tune = tuneParams('cluster.kmeans',
task = geoClstr_Task,
resampling = geoClstr_resample,
par.set = geoClstr_param,
control = geoClstr_ctrl,
measures = list(db),)
geoClstr_param <- makeParamSet(
makeDiscreteParam('centers', values = c(2:20))
)
geoClstr_tune = tuneParams('cluster.kmeans',
task = geoClstr_Task,
resampling = geoClstr_resample,
par.set = geoClstr_param,
control = geoClstr_ctrl,
measures = list(db),)
geoClstr_learner = setHyperPars(makeLearner('cluster.kmeans'),
par.vals = geoClstr_tune$x)
geoCluster_model = train(task = geoTask, learner = geoLearner)
geoCluster = list(model = geoCluster_model,
vars = geo_cluster_vars)
geoTask
geoCluster_model = train(task = geoClstr_Task, learner = geoClstr_learner)
geoCluster_model
geoClstr_tune$x
geoClstr_tune$x
geoClstr_learner = setHyperPars(makeLearner('cluster.kmeans'),
par.vals = 8)
generateHyperParsEffectData(geoClstr_tune)
geoClstr_tune = tuneParams('cluster.kmeans',
task = geoClstr_Task,
resampling = geoClstr_resample,
par.set = geoClstr_param,
control = geoClstr_ctrl,
measures = list(db, setAggregation('db', 'dunn', 'G1')))
geoClstr_tune = tuneParams('cluster.kmeans',
task = geoClstr_Task,
resampling = geoClstr_resample,
par.set = geoClstr_param,
control = geoClstr_ctrl,
measures = list(db, setAggregation('db', 'dunn', 'silhouette')))
geoClstr_tune = tuneParams('cluster.kmeans',
task = geoClstr_Task,
resampling = geoClstr_resample,
par.set = geoClstr_param,
control = geoClstr_ctrl,
measures = list(db, setAggregation('db', 'dunn')))
setAggregation('db', 'dunn')
geoClstr_tune = tuneParams('cluster.kmeans',
task = geoClstr_Task,
resampling = geoClstr_resample,
par.set = geoClstr_param,
control = geoClstr_ctrl,
measures = list(db, setAggregation(db, dunn, G1, silhouette)))
geoClstr_tune = tuneParams('cluster.kmeans',
task = geoClstr_Task,
resampling = geoClstr_resample,
par.set = geoClstr_param,
control = geoClstr_ctrl,
measures = list(db, setAggregation(db, dunn, G1)))
geoClstr_tune = tuneParams('cluster.kmeans',
task = geoClstr_Task,
resampling = geoClstr_resample,
par.set = geoClstr_param,
control = geoClstr_ctrl,
measures = list(db, setAggregation(db, dunn)))
geoClstr_tune = tuneParams('cluster.kmeans',
task = geoClstr_Task,
resampling = geoClstr_resample,
par.set = geoClstr_param,
control = geoClstr_ctrl,
measures = list(db, dunn))
geoClstr_tune = tuneParams('cluster.kmeans',
task = geoClstr_Task,
resampling = geoClstr_resample,
par.set = geoClstr_param,
control = geoClstr_ctrl,
measures = list(db, G1))
geo_cluster_vars = c("longitude",
"latitude"#,
#                     "altitude_metres"
)
geoClstr_Task = makeClusterTask(data = prediction_set_complete[,geo_cluster_vars])
geoClstr_param <- makeParamSet(
makeDiscreteParam('centers', values = c(2:20))
)
geoClstr_resample = makeResampleDesc('CV', iters = 3)
geoClstr_ctrl = makeTuneControlGrid()
geoClstr_tune = tuneParams('cluster.kmeans',
task = geoClstr_Task,
resampling = geoClstr_resample,
par.set = geoClstr_param,
control = geoClstr_ctrl,
measures = list(db, G1))
prediction_set_complete
prediction_set_complete[,c("longitude",
"latitude",
"altitude_metres")]
plot(prediction_set_complete[,c("altitude_metres")])
hist(prediction_set_complete[,c("altitude_metres")])
prediction_set_complete$altitude_metres_log = log(prediction_set_complete$altitude_metres)
prediction_set_complete$altitude_metres_log = log(prediction_set_complete$altitude_metres + 0.01)
prediction_set_complete$altitude_metres
summary(prediction_set_complete$altitude_metres)
